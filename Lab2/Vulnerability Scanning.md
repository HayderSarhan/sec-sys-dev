# Vulnerability Scanning

## Task 1

All the tools in this task will be running in a virtual environment that I created called `SAST-Tools`

## **bandit (Python):**

- **Install & run:**

    I installed bandit by following the [documentation](https://bandit.readthedocs.io/en/latest/start.html) and cloned the [vulpy](https://github.com/fportantier/vulpy)

    ![bandit_check](src/bandit_check.png)

    Running the tool and saving the output in `bandit-finding.json`:

    ![bandit_run](src/bandit_run.png)

- **Findings, CWEs and mitigation:**

    According to the generated report we have:

  - Total issues (by severity):
        - 4 issues with `HIGH` severity
        - 36  issues with `MEDIUM` severity
        - 9 issues with `LOW` severity
    - Total issues (by confidence):
      - 4 issues with `HIGH` confidence
        - 39 issues with `MEDIUM` confidence
        - 6 issues with `LOW` confidence

    ---

    **High Severity Finding:**

    **Issue:** Flask app running with `debug=True`

    - **File:** `vulpy/bad/vulpy-ssl.py` (Line 29)
    - **CWE:** [CWE-94: Improper Control of Generation of Code ('Code Injection')](https://cwe.mitre.org/data/definitions/94.html)
    - **Description:** Running a Flask app with `debug=True` enables, which allows remote users to execute arbitrary Python code if they can access the debugger interface. This poses a critical security risk, especially in production environments.

    **Mitigation:**

    - Never run Flask with `debug=True` in production. Instead, explicitly set it to `False` in a production environment.
    - Restrict access to the Flask app with proper authentication and firewall rules.

    ---

    **Medium Severity Finding:**

    **Issue:** HTTP request without a timeout

    - **File:** `vulpy/bad/api_list.py` (Line 10)
    - **CWE:** [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)
    - **Description:** The script makes an HTTP request using `requests.get()` without specifying a timeout. This can lead to the program hanging indefinitely if the server does not respond, potentially causing resource exhaustion.

    **Mitigation:**

    - Specify a timeout when making HTTP requests to avoid indefinite blocking.

        ```python
        r = requests.get('http://127.0.1.1:5000/api/post/{}'.format(username), timeout=5)
        ```

    - Handle exceptions such as `requests.exceptions.Timeout` to gracefully handle timeouts.

    ---

    **Low Severity Finding:**

    **Issue:** Usage of `subprocess` module

    - **File:** `vulpy/bad/brute.py` (Line 3)
    - **CWE:** [CWE-78: Improper Neutralization of Special Elements used in an OS Command](https://cwe.mitre.org/data/definitions/78.html)
    - **Description:** The `subprocess` module can be exploited if user input is passed unsafely, leading to command injection vulnerabilities. Although this finding is classified as **Low** severity in this case, it could become critical if input sanitization is not performed properly.

    **Mitigation:**

    - If possible, use safer alternatives like built-in Python libraries instead of shell commands.
    - If user input must be included, properly sanitize and validate it before execution.

## **flawfinder (C):**

- **Install & run:**

    Just like the last tool, I installed the tool following the [documentation](https://github.com/david-a-wheeler/flawfinder/blob/master/INSTALL.md) in the tools repository, then cloned the repository we are scanning [Damn_Vulnerable_C_Program](https://github.com/hardik05/Damn_Vulnerable_C_Program)

    ![flawfinder_check](src/flawfinder_check.png)

    When running the scan I stored the findings in two HTML files:

  - One with all the findings that the tool found in the app
    - One with findings too, but I used the `-F` flag to omit possible false/positive cases

    This will help us identify false/positive cases, by comparing both reports.

    ![flawfinder_run](src/flawfinder_run.png)

    Reference: [Flawfinder Documentation](https://dwheeler.com/flawfinder/flawfinder.pdf)

- **Findings, CWEs and mitigation:**

    According to the report, we had 84 hits in 1497 lines of code:

  - 2 level `[1]` hits
    - 82 level `[2]` hits

    When omitting the possible false/positive hits, we got 43 hits only, all of the possible false/positive cases where in the level `[2]` hits

    ---

    **Level 2 Vulnerability**

    **Issue:** Insecure file handling with `fopen()`

    - **File:** `Damn_Vulnerable_C_Program-master/dvcp.c` (Line 33)
    - **CWE:** [CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)
    - **Description:** The use of `fopen()` without proper validation and security measures can lead to several risks, such as:
      - **Symlink attacks:** An attacker could create a symbolic link to trick the program into opening or overwriting unintended files.
        - **Race conditions:** If the file is checked before opening, an attacker might change the file before it is actually opened.

    **Mitigation:**

    - Validate input filename to ensure it doesn’t point to a symbolic link by using functions like:
      - [S_ISLNK](http://porthos.ist.utl.pt/docs/fpc/units/node303.html)
        - [lstat](https://pubs.opengroup.org/onlinepubs/007904875/functions/lstat.html)
    - Set strict file permissions using `chmod()`

    ---

    **Level 1 Vulnerability**

    **Issue:** Unchecked buffer boundaries in `read()`

    - **File:** `Damn_Vulnerable_C_Program-master/linux/imgRead_socket.c` (Line 74)
    - **CWE:**
      - [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)
        - [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)
    - **Description:** The `read()` function is used to read data from a socket without checking buffer boundaries. If the incoming data is larger than expected, it may lead to **buffer overflow**, potentially overwriting adjacent memory. This can cause crashes, data corruption, or even remote code execution.

    **Mitigation:**

    - Ensure that `read()` never exceeds the buffer size, and terminate when detecting a buffer overflow

    ---

- **False/Positive Findings:**

    As mentioned before the report had 41 possible false/positive cases, one of them is the following:

    **Issue:** Statically-sized arrays

  - **File:** `Damn_Vulnerable_C_Program-master/dvcp.c:16`
    - **CWE:**
      - [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)
        - [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)
    - This is a false/positive case because:
      - The arrays are probably defined
        - There are no tries in the code to write to this array, going over their boundaries

## **njsscan (NodeJS)**

- **Install & run:**

    ![njsscan_check](src/njsscan_check.png)

    Running the tool and saving the findings in a `json` file

    ![njsscan_run](src/njsscan_run.png)

- **Findings, CWEs and mitigations:**

    In the report there was:

  - 4 findings with the severity **INFO**
    - 4 findings with the severity **WARNING**
    - 4 findings with the severity **ERROR**

    ---

    **INFO:**

    **Issue:** Default Cookie Session

    - **File:** `dvna/server.js` (Lines [23, 28])
    - **CWE:** [CWE-522: Insufficiently Protected Credentials](https://cwe.mitre.org/data/definitions/522.html)
    - **Description:** The session cookie uses its default name, which can help attackers fingerprint the server and craft targeted attacks.
    - **Mitigation:**
      - Change the default session name:

        ```jsx
        app.use(session({
            name: 'my_secure_session',
            secret: 'keyboard cat',
            resave: true,
            saveUninitialized: true,
        }));
        ```

    ---

    **WARNING:**

    **Issue:** Missing SameSite Attribute in Cookies

    - **File:** `dvna/server.js` (Lines [23, 28])
    - **CWE:** [CWE-1275: Sensitive Cookie with Improper SameSite Attribute](https://cwe.mitre.org/data/definitions/1275.html)
    - **Description:** The session cookie doesn’t have the `SameSite` attribute, which helps prevent Cross-Site Request Forgery (CSRF) attacks. Without this, a user's session could be exploited by an attacker tricking them into making unintended authenticated requests.
    - **Mitigation:**
      - Set a value to the SameSite attribute in the session cookie:

        ```jsx
        app.use(session({
            name: 'my_secure_session',
            secret: 'keyboard cat',
            resave: true,
            saveUninitialized: true,
            cookie: { secure: true, sameSite: 'Lax' }
        }));
        ```

        **References:**

        - [The SameSite Attribute](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7)
        - ["Strict" and "Lax" enforcement](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-03#section-5.3.7.1)

    ---

    **ERROR:**

    **Issue:** Open Redirect

    - **File:** `dvna/core/appHandler.js` (Line 188)
    - **CWE:** [CWE-601: URL Redirection to Untrusted Site ('Open Redirect')](https://cwe.mitre.org/data/definitions/601.html)
    - **Description:** The application redirects users to URLs provided in the query string without validation. An attacker can exploit this by crafting malicious links that appear to be from the trusted site but actually lead to phishing sites.
    - **Mitigation:**
      - Validate and whitelist redirect URLs to ensure they only point to trusted domains.
        - Maintain a server-side list of all URLs that are permitted for redirection.

            Example:

            ```jsx
            const allowedDomains = ['example.com', 'myapp.com'];
            const url = new URL(req.query.url, 'https://defaultsite.com');
            if (allowedDomains.includes(url.hostname)) {
                res.redirect(url.href);
            } else {
                res.status(400).send('Invalid redirect URL');
            }
            ```

## Task 2

- **Installing BurpSuite-CE:**

    Downloading BurpSuite was simple, I just went to the [download page](https://portswigger.net/burp/releases/professional-community-2025-1-2?requestededition=community&requestedplatform=) and downloaded the app.

    ![BurpSuite](src/BurpSuite.png)

- **Running the app, solving it and explain findings:**
  - **Cross Site Scripting**

    ![XSS_docker](src/XSS_docker.png)

    In BrupSuite we go to target > open browser, and we can open our vulnerable app there

    ![XSS_run](src/XSS_run.png)

    Injecting a XSS:

    ![XSS_injection](src/XSS_injection.png)

    ![XSS_success](src/XSS_success.png)

    In BurpSuite we can check the request and the response:

    ![XSS_analys](src/XSS_analys.png)

    - What is **Cross Site Scripting(XSS)?**

        Cross-site scripting (XSS) is a security flaw in websites that lets hackers insert harmful scripts into web pages. This allows them to act as another user, steal data, or even take full control of an application if the user has special access.

    - How to prevent **Cross Site Scripting** attacks?

        To prevent XSS attacks, we have to always sanitize user’s input and never display data from users on the website without first checking and removing any harmful code or scripts.

        **Reference:** [Cross-site scripting](https://portswigger.net/web-security/cross-site-scripting#what-is-cross-site-scripting-xss)

    - **Path Traversal**

        ![path_traversal_docker](src/path_traversal_docker.png)

        ![path_traversal_run](src/path_traversal_run.png)

        We notice that the request is retrieving a file from the app using a variable `filename`.

        We can take advantage of this by repeating the request to expose sensitive data from the target app.

        To repeat a request we right-click on the request we want to repeat > Send to Repeater

        Now if we go to the Repeater tab we can see the request there and we can send another one with our changes:

        ![path_traversal_success](src/path_traversal_success.png)

      - What is **Path traversal**?

        Path traversal is a security weakness that lets attackers access files on a server that they shouldn’t be able to see. This could include sensitive data, passwords, or system files. In some cases, they might even change files, which can lead to full control of the server.

        - How to prevent **Path traversal** attacks?

            The best way to prevent path traversal is to avoid using user input in file paths. If that’s not possible, we can use two layers of protection:

            1. **Validate input:** Only allow safe, expected values (like specific filenames or alphanumeric characters).
            2. **Check file paths:** Ensure the final file path is inside the correct directory before allowing access.

        **Reference:** [Path traversal](https://portswigger.net/web-security/file-path-traversal)

    - **SQL Injection**

        ![SQLi_docker](src/SQLi_docker.png)

        ![SQLi_run](src/SQLi_run.png)

        After running multiple queries and SQL injections on the app we notice that the database has three columns, proving that the app doesn’t sanitize the data it receives from the users

        ![SQLi_seccess](src/SQLi_seccess.png)

        We also notice that when we enter a wrong query, we get an insight on the apps logs

        ![SQLi_note](src/SQLi_note.png)

      - What are **SQL Injections**?

        SQL injection is a vulnerability that lets attackers manipulate a website’s database queries. This can allow them to see, change, or delete data they shouldn’t have access to. In severe cases, they might even take over the server or disrupt the application.

        - How can we prevent **SQL Injections**?

            Use **parameterized queries (prepared statements)** instead of directly inserting user input into SQL queries. This ensures that input is treated as data, not code.

            **Whitelists** can be used too to allow only safe values.

        **Reference:** [SQL injection](https://portswigger.net/web-security/sql-injection#what-is-sql-injection-sqli)

    - **File Upload**

        ![file_upload_docker](src/file_upload_docker.png)

        ![file_upload_run](src/file_upload_run.png)

        To get a better understanding on how this app work, we need to understand the files structure for this app.

        ![file_upload_analys_1](src/file_upload_analys_1.png)

        We notice that it’s the structure of a flask app, when we open the `File-upload.py` file we notice that there is a restriction on the type of files we can upload:

        ![file_upload_analys_2](src/file_upload_analys_2.png)

        From this we now know:

      - What type of file should the payload be
        - What files can the payload overwrite

        ![file_upload_inject](src/file_upload_inject.png)

        We uploaded the file, now all we have to do is repeat the request so we can put the payload in the templates directory and overwrite the `index.html` in the app.

        ![file_upload_traversal](src/file_upload_traversal.png)

        Now when we refresh the app’s page we get:

        ![file_upload_success](src/file_upload_success.png)

        - What are **File Upload** attacks?

            File upload attacks happen when a website allows users to upload files without properly checking them. Attackers can exploit this to upload harmful files, like scripts that let them take control of the server. In some cases, simply uploading the file can cause damage, while others require an extra request to trigger the attack.

        - How can we prevent **File Upload** attacks?

            To safely allow file uploads:

            - **Check filenames** to prevent tricks like directory traversal (`../`).
            - **Rename uploaded files** to prevent overwriting existing ones.
            - **Validate files before saving them permanently** on the server.

        **Reference:** [File upload vulnerabilities](https://portswigger.net/web-security/file-upload#what-are-file-upload-vulnerabilities)

    - **Command Injection**

        ![command_inject_docker](src/command_inject_docker.png)

        ![command_inject_run](src/command_inject_run.png)

        When testing we notice that when we resize the image, the value is sent through the size variable in the request, we can try to change the value of it to inject our command:

        ![command_inject_analys1](src/command_inject_analys1.png)

        If we check the logs of the app we see the following:

        ![command_inject_analys2](src/command_inject_analys2.png)

        this shows that the app is vulnerable to command injection attacks

        We can run a different command to delete the `index.html` file from the app:

        ![command_inject_test](src/command_inject_test.png)

        ![command_inject_success](src/command_inject_success.png)

    - What are **Command Injection** attacks?

        OS command injection (or shell injection) is a security vulnerability where an attacker can run operating system commands on a server through a web application. This can let them take full control of the server, access data, and potentially attack other parts of the infrastructure.
    - How can we prevent **Command Injection** attacks?

        To prevent OS command injection we should:
        - Avoid using OS commands in the application code.
        - Validate input strictly.
